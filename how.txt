let's first do it with a lookup
then lets do it with a function that takes a room and a number and calculates a unique number. this needs to be reversible somehow though, which is the beauty of the lookup table

so let's do an example with 2 rooms 2 numbers

there are n rooms, m monopoles, trying to get list S of n sets

    Given: n rooms. A set 1..m of monopoles to place.

    Find: A list S of n sets with the following properties:

        Each monopole is placed:

        forall i in {1..m} .
            exists j in {1..n} .
                i in S[j]


so (1a or 1b) and (2a or 2b)


        No monopole is in two places:

        forall i in {1..m} .
            forall j, k in {1..n} .
                j ≠ k → i not in S[j] or i not in S[k]


(1a or 1b) and (~1a or ~1b) // this works for just 2 things, how about 3+?
there we gooo!
((!1a or 1b or 1c) and (1a or !1b or 1c) and (1a or 1b or !1c))
((!1a or 1b) and (1a or !1b) and ((!2a or 2b) and (2a or !2b) 

        Sums exclude monopoles:

        forall i in {1..n} .
           forall j, k in {1..m} .
               j ≠ k → j not in S[i] or k not in S[i] or j + k not in S[i]

here:

(!1a or !2a or !3a) and (!1b or !2b or !3b)

(!1a or !2a or !3a) 


















so how the fuck does this work??

holy shit. This is way more next level how hes doing it.
each element in the array is a variable in the csp????
I see how that works for the last set of constrains, but how does it work for the first set of constraints?

(S[a][1] or S[b][1]) and (S[a][1] or S[b][2])



there are n rooms, m monopoles, trying to get list S of n sets

    Given: n rooms. A set 1..m of monopoles to place.

    Find: A list S of n sets with the following properties:

        Each monopole is placed:

        forall i in {1..m} .
            exists j in {1..n} .
                i in S[j]

so this one is like: 
    a bunch of ands between every number
    what does the actual 'or' clause look like though
    for number a (room 1 or room 2) and for number b (room 1 or room 2)
    
holy shit is each parethases a room??
no, but maybe almost?
ooooooooh the variables are the number x room
2 rooms 2 numbers

so (1a or 1b) and (2a or 2b)


how do I make these unique keys?
do I make a dict before hand that I use as a translation tool?
- why not. it's a dict's job to be a dict

now we're trying this:
(S[a][1] or S[b][1]) and (S[a][1] or S[b][2])

        No monopole is in two places:

        forall i in {1..m} .
            forall j, k in {1..n} .
                j ≠ k → i not in S[j] or i not in S[k]

sooooo:
1 can be in a or b, but not a and b
how do I put this into cnf?

(1a or 1b) and (~1a or ~1b) // this works for just 2 things, how about 3+?
there we gooo!
((!1a or 1b or 1c) and (1a or !1b or 1c) and (1a or 1b or !1c))




        Sums exclude monopoles:

        forall i in {1..n} .
           forall j, k in {1..m} .
               j ≠ k → j not in S[i] or k not in S[i] or j + k not in S[i]

what the fuck is S[i] 

so it's like I'll be using the lookup table for all of this stuff:
so i go through the list and i get a room, and then I get a number
so i want to say in a prop. logic statement that
I can have a and I can have b but if I do I cant have a + b and a and b
so it's that similar to:
(!1a or !2a or !3a) 

j can't be the same as s[i]?

if j != k:
    j ! in s[i] or k ! in s[i] or j + k not in s[i]

when I get it back out I just need to feed the true guys into the dict and that will give me the values that are true.
